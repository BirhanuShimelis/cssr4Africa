/******************************************************************************

global variables with the current robot pose

*******************************************************************************/

/* global variables with the initial and current robot pose, the odometry pose, and the difference between the initial pose and the initial odometry pose  */

double                  initial_x        = 0; 
double                  initial_y        = 0;
double                  initial_theta    = 0;
double                  current_x        = 0; 
double                  current_y        = 0; 
double                  current_theta    = 0;
double                  odom_x           = 0;
double                  odom_y           = 0;
double                  odom_theta       = 0;
double                  adjustment_x     = 0; 
double                  adjustment_y     = 0;
double                  adjustment_theta = 0;

/******************************************************************************

odomMessageReceived

Callback function, executed each time a new pose message arrives 

*******************************************************************************/

void odomMessageReceived(const nav_msgs::Odometry &msg)
{
   bool debug = true;

   double x, y;

   odom_x = msg.pose.pose.position.x;
   odom_y = msg.pose.pose.position.y;
   odom_theta = 2 * atan2(msg.pose.pose.orientation.z, msg.pose.pose.orientation.w);

   /* change frame of reference from arbitrary odometry frame of reference to the world frame of reference */

   /* translation of origin */

   x = odom_x + adjustment_x - initial_x;
   y = odom_y + adjustment_y - initial_y;

   /* rotation about origin */

   current_x = x * cos(adjustment_theta) + y * -sin(adjustment_theta);
   current_y = x * sin(adjustment_theta) + y * cos(adjustment_theta);

   current_x += initial_x;
   current_y += initial_y;

   current_theta = odom_theta + adjustment_theta;

   /* check to ensure theta is still in the range -PI to +PI */

   if (current_theta < -PI)
      current_theta += 2 * PI;
   else if (current_theta > PI)
      current_theta -= 2 * PI;

   // printf("odom_x,y,theta %5.3f %5.3f %5.3f; adjustment_x,y,theta  %5.3f %5.3f %5.3f; x, y %5.3f %5.3f; current_x,y,theta %5.3f %5.3f %5.3f\n",  odom_x, odom_y, odom_theta, adjustment_x, adjustment_y, adjustment_theta, x, y, current_x, current_y, current_theta);

   if (debug)
   {
      // printf("Odometry: position = (%5.3f, %5.3f) orientation = %5.3f\n", current_x, current_y, current_theta);
      ROS_INFO_THROTTLE(1, "Odometry: position = (%5.3f, %5.3f) orientation = %5.3f", current_x, current_y, current_theta);

   }
   
}



/*********************************************************************************

setOdometryPose

Initialize the pose returned by the callback that services the subscription to the odom topic         
                                                                                                       
Odometry provides relative position orientation. Since we can't assume what odometry data is published
on the odom topic on start up, we use two extra sets of variables for the x, y, and theta values:     
adjustment variables and current variables.                                                           
                                                                                                      
We set the values of the adjustment variables to be the difference between                            

(a) the values associated with the start pose, and                                                    
(b) the values published on the odom topic on start up (or whenever we reinitialize the odometry),    
                                                                                                      
The callback then sets the values of the current variables as follows.

- the current x and y values are set to the sum of the adjustment x and y values and the odom x and y values 
  (this effectively translates the odom x and y values by the adjustment x and y values) 

- these translated values are then rotated about the Z axis by an angle equal to the difference 
  between the start theta value  and the odom theta value

- the current theta value is set to be the sum of the adjustment theta value and the odom theta value                                                            

**********************************************************************************/

void setOdometryPose(double x, double y, double theta)
{

   bool debug = false;

   sleep(1); // allow time for messages to be published on the odom topic
   ros::spinOnce();

   /* store the initial pose */
   initial_x = x;
   initial_y = y;
   initial_theta = theta;

   /* calculate the adjustment to the pose, i.e. the difference between the initial pose and odometry pose */
   adjustment_x = x - odom_x;
   adjustment_y = y - odom_y;
   adjustment_theta = theta - odom_theta;

   // sleep(1); // allow time for adjusted  messages to be published on the odom topic
   // ros::spinOnce();

   if (debug)
   {
      printf("setOdometryPose: odom_x,y,theta %.2f %.2f %.2f  adjustment_x, y, theta %.2f %.2f %.2f\n", odom_x, odom_y, odom_theta,
             adjustment_x, adjustment_y, adjustment_theta);
   }
}
